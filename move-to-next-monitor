#!/bin/bash
#
# Move the current window to the next monitor.
#
# Also works only on one X screen (which is the most common case).
#
# Props to
# http://icyrock.com/blog/2012/05/xubuntu-moving-windows-between-monitors/
#
# Unfortunately, both "xdotool getwindowgeometry --shell $window_id" and
# checking "-geometry" of "xwininfo -id $window_id" are not sufficient, as
# the first command does not respect panel/decoration offsets and the second
# will sometimes give a "-0-0" geometry. This is why we resort to "xwininfo".
#
# algorithm:
#  get_monitors dimensions and offset
#  get_current_window position and maximized status
#  find next monitor
#  compute new coordinate in the next monitor
#  move to the next monintor centered maxmize if it was
#
# bash array remainder: (Yes, array syntax is totally ugly)
#   # create an array
#   arr=( val1 val2 )
#   # get element 0
#   ${arr[0]}
#   # all elements
#   ${arr[@]}
#   # number of elements
#   ${#arr[@]}

[[ $0 != "$BASH_SOURCE" ]] && sourced=1 || sourced=0
if [[ $sourced -eq 0  ]]
then
  me=$(readlink -f $0)
else
  me=$(readlink -f "$BASH_SOURCE")
fi
mydir=$(dirname $me)

# get_monitors output:
# LVDS-1 1366 768 0 515
# OTHER 1280 1024 1366 0
get_monitors() {
  OFFSET_RE="([0-9]+)\+([0-9]+)"

  xrandr | 
    sed -nr "/ connected / {
      s/^([^ ]*).*\b([0-9]+)x([0-9]+)\+$OFFSET_RE.*$/\1 \2 \3 \4 \5/ p
    }"
}

fake_get_monitors() {
  echo LVDS-1 1366 768 0 572
  echo VGA-1 1280 1024 1366 0
}

#get_monitors() {
#  fake_get_monitors
#}

get_current_window() {
  # current window_id
  local window_id=`xdotool getactivewindow`

  # Remember if it was maximized.
  window_horz_maxed=`xprop -id $window_id _NET_WM_STATE \
    | grep '_NET_WM_STATE_MAXIMIZED_HORZ'`
  window_vert_maxed=`xprop -id $window_id _NET_WM_STATE \
    | grep '_NET_WM_STATE_MAXIMIZED_VERT'`

  echo $window_id
}

window_get_position() {
  local window_id=$1

  # Read window position
  x=`xwininfo -id $window_id | awk '/Absolute upper-left X:/ { print $4 }'`
  y=`xwininfo -id $window_id | awk '/Absolute upper-left Y:/ { print $4 }'`

  # Subtract any offsets caused by panels or window decorations
  x_offset=`xwininfo -id $window_id \
    | awk '/Relative upper-left X:/ { print $4 }'`
  y_offset=`xwininfo -id $window_id \
    | awk '/Relative upper-left Y:/ { print $4 }'`

  x=`expr $x - $x_offset`
  y=`expr $y - $y_offset`

  pos=( `xdotool getwindowgeometry $window_id | awk -F '[ x]+' '/Geometry:/ { print $3,$4 }'` )
  echo "$x $y ${pos[@]}"
}

get_merged_display() {
  #xdpyinfo | grep dimensions:
  #  dimensions:    2646x1340 pixels (700x355 millimeters)
  # virtual screen monitor merged dimensions including offsets
  xdpyinfo | awk -F '[ x]+' '/dimensions:/ { print $3,$4}'
}

compute_window_center() {
  # array assign
  local pos=( $@ )
  echo $((${pos[0]} + (${pos[2]}) / 2)) $((${pos[1]} + (${pos[3]}) / 2))
}

window_compute_move() {
  local window_id=$1

  local screens=( $(get_monitors) )
  local nbscreen=${#screen[@]}
  if [[ $nbscreen -eq 1 ]] ; then
    return 1
  fi

  local pos=( $(window_get_position $window_id) )
  local center=( $(compute_window_center ${pos[@]}) )

  # we suppose that monitor are ordered
  # window coordinate and center are given relative to screen 0
  while read name width height xoff yoff
  do
    echo $name $width $height $xoff $yoff
    if [ "${center[0]}" -ge "$xoff" \
      -a "${center[1]}" -ge "$yoff" \
      -a "${center[0]}" -lt "$(($xoff+$width))" \
      -a "${center[1]}" -lt "$(($yoff+$height))" ]
    then
      monitor=$name   
    fi
  done < <(get_monitors)
  echo m=$monitor
  return 

  # current window screen's dimension
  display_width=`xdotool getdisplaygeometry | cut -d" " -f1`
  display_height=`xdotool getdisplaygeometry | cut -d" " -f2`

  merge_screen=( $(get_merged_display) )

  # Compute new X position
  new_x=`expr $x + ${merge_screen[0]}`
  # Compute new Y position
  new_y=`expr $y + ${merge_screen[1]}`

  # If we would move off the right-most monitor, we set it to the left one.
  # We also respect the window's width here: moving a window off more than half its width won't happen.
  width=`xdotool getwindowgeometry $window_id | awk '/Geometry:/ { print $2 }'|cut -d"x" -f1`
  if [ `expr $new_x + $width / 2` -gt $screen_width ]; then
    new_x=`expr $new_x - $screen_width`
  fi

  height=`xdotool getwindowgeometry $window_id | awk '/Geometry:/ { print $2 }'|cut -d"x" -f2`
  if [ `expr $new_y + $height / 2` -gt $screen_height ]; then
    new_y=`expr $new_y - $screen_height`
  fi

  # Don't move off the left side.
  if [ $new_x -lt 0 ]; then
    new_x=0
  fi

  # Don't move off the bottom
  if [ $new_y -lt 0 ]; then
    new_y=0
  fi
}

main() {
  # current window properties
  window_id=$(get_current_window)

  new_coord=( $(window_compute_move $window_id) )

  # Un-maximize current window so that we can move it
  wmctrl -ir $window_id -b remove,maximized_vert,maximized_horz

  # Move the window
  xdotool windowmove $window_id ${new_coord[@]}

  # Maximize window again, if it was before
  if [ -n "${window_horz_maxed}" -a -n "${window_vert_maxed}" ]; then
    wmctrl -ir $window_id -b add,maximized_vert,maximized_horz
  elif [ -n  "${window_horz_maxed}" ]; then
    wmctrl -ir $window_id -b add,maximized_horz
  elif [ -n  "${window_vert_maxed}" ]; then
    wmctrl -ir $window_id -b add,maximized_vert
  fi
}


if [[ $sourced -eq 0  ]] ; then
  main "$@"
fi

